<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess — Play vs Bot </title>
<link rel="preconnect" href="https://fonts.gstatic.com">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

  :root{
    --bg:#071223;
    --panel:#0b1622;
    --accent:#22c55e;
    --muted:#9fb1c7;
    --light:#e6f7ff;
    --sq-light:#f0d9b5;  /* classic light */
    --sq-dark:#b58863;   /* classic dark */
    --glass: rgba(255,255,255,0.03);
    --board-size: 720px; /* bigger board */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#07182b);font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--light)}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px}

  .app{width:100%;max-width:1300px;display:grid;grid-template-columns: var(--board-size) 1fr;gap:28px;align-items:start}
  @media(max-width:1100px){ .app{grid-template-columns: 1fr; } }

  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 12px 40px rgba(2,8,20,0.6)}

  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  .title{font-weight:700;color:var(--accent);display:flex;gap:10px;align-items:center}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--glass);color:var(--light);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);cursor:pointer;font-weight:600}
  .btn.primary{background:linear-gradient(90deg,#10b981,#34d399);color:#042014;border:none}
  .badge{padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,#0ea5a1,#1f9a57);color:#042014;font-weight:700}

  /* board */
  .board{width:var(--board-size);height:var(--board-size);display:grid;grid-template-columns:repeat(8,1fr);gap:0;border-radius:12px;overflow:hidden;position:relative;user-select:none;touch-action:manipulation}
  .square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative;font-size:40px;transition:background .12s, transform .12s}
  .square.light{background:var(--sq-light)}
  .square.dark{background:var(--sq-dark)}
  .piece{position:relative;width:64px;height:64px;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .piece .circle{position:absolute;width:64px;height:64px;border-radius:50%;z-index:0;box-shadow:0 8px 22px rgba(2,8,20,0.5)}
  .piece .char{position:relative;z-index:1;font-size:32px;font-weight:700}
  /* clear visual for white/black pieces */
  .piece.white .circle{background:#ffffff}
  .piece.white .char{color:#111}
  .piece.black .circle{background:#0b1220;border:2px solid #d1d1d1}
  .piece.black .char{color:#f4f4f4}

  .highlight{box-shadow:inset 0 0 0 4px rgba(34,197,94,0.18);border-radius:6px;animation:pulse 1.2s infinite}
  @keyframes pulse{0%{box-shadow:inset 0 0 0 4px rgba(34,197,94,0.18)}50%{box-shadow:inset 0 0 0 6px rgba(34,197,94,0.10)}100%{box-shadow:inset 0 0 0 4px rgba(34,197,94,0.18)}}
  .lastMove{outline:3px solid rgba(59,130,246,0.22);border-radius:6px}

  /* marker for legal moves */
  .marker-dot{width:14px;height:14px;border-radius:50%;background:rgba(34,197,94,0.95);opacity:0.95;box-shadow:0 6px 18px rgba(34,197,94,0.08);}

  /* right panel */
  .info{display:flex;flex-direction:column;gap:12px;height:var(--board-size)}
  .players{display:flex;justify-content:space-between;align-items:center}
  .player{display:flex;gap:12px;align-items:center}
  .avatar{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,#d1fae5,#bbf7d0);display:flex;align-items:center;justify-content:center;font-weight:700;color:#065f46;box-shadow:0 6px 18px rgba(16,185,129,0.08)}
  .status{padding:12px;border-radius:10px;background:var(--glass);font-weight:700;text-align:center;color:#cfeffd}
  .history{flex:1;overflow:auto;padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);color:#cfeffd;font-size:14px}
  .move{padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));display:flex;justify-content:space-between;align-items:center}
  .footer{display:flex;justify-content:space-between;align-items:center}

  .legend{font-size:13px;color:var(--muted);text-align:center;padding:6px 0}

  .small{font-size:13px;color:var(--muted)}

  /* responsive */
  @media(max-width:1100px){
    .board{width:92vw;height:92vw}
    .info{height:auto}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="app">
    <!-- BOARD PANEL -->
    <div class="panel">
      <div class="top">
        <div class="title">♟ Chess — Play vs BOT</div>
        <div class="controls">
          <div id="turnBadge" class="badge">White to move</div>
          <button class="btn" id="undoBtn">Undo</button>
          <button class="btn primary" id="resetBtn">Reset</button>
          <button class="btn" id="flipBtn">Flip</button>
        </div>
      </div>

      <div id="board" class="board" role="grid" aria-label="chess board"></div>
      <div class="legend">White = You (bottom) • Black = Bot (top)</div>
    </div>

    <!-- INFO PANEL -->
    <div class="panel info">
      <div class="players">
        <div class="player">
          <div class="avatar">W</div>
          <div>
            <div style="font-weight:700">You (White)</div>
            <div class="small">White pieces are <strong>light circles</strong></div>
          </div>
        </div>
        <div class="player" style="flex-direction:row-reverse">
          <div class="avatar" style="background:linear-gradient(180deg,#dbeafe,#bfdbfe);color:#08306b">B</div>
          <div style="text-align:right">
            <div style="font-weight:700">Bot (Black)</div>
            <div class="small">Black pieces are <strong>dark circles</strong></div>
          </div>
        </div>
      </div>

      <div class="status" id="status">Ready — click a white piece to start</div>

      <div class="history" id="history" aria-live="polite"></div>

      <div class="footer">
        <div class="small">Moves: <span id="moveCount">0</span></div>
        <div style="display:flex;gap:8px">
          <button class="btn" id="exportBtn">Export</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* Same logic as before, but piece rendering updated to show clear white/black visuals.
   Win condition still: king capture = game over.
*/

// DOM
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const historyEl = document.getElementById('history');
const moveCountEl = document.getElementById('moveCount');
const turnBadge = document.getElementById('turnBadge');
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');
const flipBtn = document.getElementById('flipBtn');
const exportBtn = document.getElementById('exportBtn');

// state
let board = [];
let selected = null;
let legalMoves = [];
let historySnapshots = [];
let movesList = [];
let turn = 'w'; // 'w' or 'b'
let flip = false;
let gameOver = false;

// unicode pieces
const UNICODE = {
  w: { p:'♙', r:'♖', n:'♘', b:'♗', q:'♕', k:'♔' },
  b: { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚' }
};

// helpers
function inside(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
function getPiece(x,y){ return inside(x,y) ? board[y][x] : null; }
function setPiece(x,y,p){ if(inside(x,y)) board[y][x] = p; }
function fileRank(x,y){ const f = ['a','b','c','d','e','f','g','h']; return f[x] + (8-y); }

// init starting board
function resetBoard(){
  board = [
    [ {t:'r',c:'b'},{t:'n',c:'b'},{t:'b',c:'b'},{t:'q',c:'b'},{t:'k',c:'b'},{t:'b',c:'b'},{t:'n',c:'b'},{t:'r',c:'b'} ],
    [ {t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'} ],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [ {t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'} ],
    [ {t:'r',c:'w'},{t:'n',c:'w'},{t:'b',c:'w'},{t:'q',c:'w'},{t:'k',c:'w'},{t:'b',c:'w'},{t:'n',c:'w'},{t:'r',c:'w'} ]
  ];
  selected = null;
  legalMoves = [];
  historySnapshots = [];
  movesList = [];
  turn = 'w';
  gameOver = false;
  saveSnapshot();
  render();
  setStatus('Ready — click a white piece to start');
  updateTurnBadge();
}

// save snapshot for undo
function saveSnapshot(){
  historySnapshots.push(JSON.stringify(board));
  if(historySnapshots.length > 200) historySnapshots.shift();
}

// undo
function undo(){
  if(historySnapshots.length > 1 && !gameOver){
    historySnapshots.pop();
    board = JSON.parse(historySnapshots[historySnapshots.length - 1]);
    if(movesList.length) movesList.pop();
    turn = (turn === 'w') ? 'b' : 'w';
    selected = null; legalMoves = [];
    render();
  } else {
    alert('No move to undo or game over.');
  }
}

// generate legal-ish moves for (x,y)
// Note: does NOT check for checks. Prevents capturing own pieces.
function generateMoves(x,y){
  const p = getPiece(x,y);
  if(!p) return [];
  const moves = [];
  const color = p.c;
  const dir = (color === 'w') ? -1 : 1; // white moves up (decreasing y)
  if(p.t === 'p'){
    const ny = y + dir;
    if(inside(x,ny) && !getPiece(x,ny)) moves.push({x, y:ny});
    const startRow = (color==='w') ? 6 : 1;
    const ny2 = y + 2*dir;
    if(y === startRow && inside(x,ny2) && !getPiece(x,ny) && !getPiece(x,ny2)) moves.push({x, y:ny2});
    for(const dx of [-1,1]){
      const cx = x + dx, cy = y + dir;
      if(inside(cx,cy)){
        const target = getPiece(cx,cy);
        if(target && target.c !== color) moves.push({x:cx,y:cy});
      }
    }
  } else if(p.t === 'n'){
    const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
    deltas.forEach(d=>{
      const nx=x+d[0], ny=y+d[1];
      if(inside(nx,ny)){
        const t = getPiece(nx,ny);
        if(!t || t.c !== color) moves.push({x:nx,y:ny});
      }
    });
  } else if(p.t === 'b' || p.t === 'r' || p.t === 'q'){
    const dirs = [];
    if(p.t === 'b' || p.t === 'q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
    if(p.t === 'r' || p.t === 'q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
    dirs.forEach(d=>{
      let nx = x + d[0], ny = y + d[1];
      while(inside(nx,ny)){
        const t = getPiece(nx,ny);
        if(!t) moves.push({x:nx,y:ny});
        else {
          if(t.c !== color) moves.push({x:nx,y:ny});
          break;
        }
        nx += d[0]; ny += d[1];
      }
    });
  } else if(p.t === 'k'){
    for(const dx of [-1,0,1]){
      for(const dy of [-1,0,1]){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(inside(nx,ny)){
          const t = getPiece(nx,ny);
          if(!t || t.c !== color) moves.push({x:nx,y:ny});
        }
      }
    }
  }
  return moves;
}

// handle square click (rx,ry are board coords)
function handleClick(rx,ry){
  if(gameOver) return;
  const p = getPiece(rx,ry);
  if(selected){
    const selPiece = getPiece(selected.x, selected.y);
    if(p && p.c === selPiece.c){
      selected = {x:rx,y:ry};
      legalMoves = generateMoves(rx,ry);
      render();
      return;
    }
    const mv = legalMoves.find(m => m.x===rx && m.y===ry);
    if(mv){
      makeMove(selected.x, selected.y, rx, ry, 'w');
      selected = null; legalMoves = [];
      render();
      if(!gameOver) setTimeout(botMove, 350);
      return;
    } else {
      selected = null; legalMoves = [];
      render();
      return;
    }
  } else {
    if(p && p.c === turn){
      selected = {x:rx,y:ry};
      legalMoves = generateMoves(rx,ry);
      render();
    }
  }
}

// perform move
function makeMove(fx,fy,tx,ty, playerLabel){
  const piece = getPiece(fx,fy);
  if(!piece) return;
  const target = getPiece(tx,ty);

  setPiece(tx,ty,piece);
  setPiece(fx,fy,null);

  // promotion
  if(piece.t === 'p'){
    if((piece.c==='w' && ty===0) || (piece.c==='b' && ty===7)){
      const choice = prompt("Promotion! choose q/r/b/n (default q)", "q");
      const pr = (choice && ['q','r','b','n'].includes(choice.toLowerCase())) ? choice.toLowerCase() : 'q';
      setPiece(tx,ty,{t:pr,c:piece.c});
    }
  }

  const notation = `${piece.c}${piece.t}:${fileRank(fx,fy)}→${fileRank(tx,ty)}${target?(' x'+target.t):''}`;
  movesList.push({player: piece.c, notation, from:{x:fx,y:fy}, to:{x:tx,y:ty}});

  saveSnapshot();
  // king capture
  if(target && target.t === 'k'){
    gameOver = true;
    render();
    const winner = (piece.c === 'w') ? 'White' : 'Black';
    setStatus(`${winner} wins — King captured!`);
    setTimeout(()=> alert(`${winner} wins!`), 50);
    updateTurnBadge();
    return;
  }

  turn = (turn === 'w') ? 'b' : 'w';
  updateUI();
  updateTurnBadge();
}

// simple bot
function botMove(){
  if(gameOver) return;
  if(turn !== 'b') return;
  setStatus('Bot thinking...');
  const allMoves = [];
  for(let y=0;y<8;y++){
    for(let x=0;x<8;x++){
      const p = getPiece(x,y);
      if(p && p.c === 'b'){
        const ms = generateMoves(x,y);
        ms.forEach(m => allMoves.push({from:{x,y}, to:m}));
      }
    }
  }
  if(allMoves.length === 0){
    gameOver = true;
    setStatus('No moves for Bot — draw?');
    alert('No moves available for Bot. Game ends.');
    return;
  }

  const captures = allMoves.filter(a => getPiece(a.to.x, a.to.y));
  let choice;
  if(captures.length > 0 && Math.random() < 0.7){
    choice = captures[Math.floor(Math.random() * captures.length)];
  } else {
    choice = allMoves[Math.floor(Math.random() * allMoves.length)];
  }

  makeMove(choice.from.x, choice.from.y, choice.to.x, choice.to.y, 'b');
  render();
}

// UI helpers
function setStatus(s){ statusEl.innerText = s; }
function updateUI(){
  moveCountEl.innerText = movesList.length;
  turnBadge.innerText = (turn === 'w') ? 'White to move' : 'Black to move';
  setStatus(gameOver ? 'Game over' : `${turn === 'w' ? 'Your' : 'Bot'} turn`);
}
function updateTurnBadge(){
  if(gameOver){
    turnBadge.style.background = 'linear-gradient(90deg,#444,#666)';
    turnBadge.style.color = '#fff';
    return;
  }
  if(turn === 'w'){
    turnBadge.style.background = 'linear-gradient(90deg,#fff,#f2f2f2)';
    turnBadge.style.color = '#072018';
  } else {
    turnBadge.style.background = 'linear-gradient(90deg,#0b1220,#222831)';
    turnBadge.style.color = '#f3f4f6';
  }
}

// render board visually (with clear piece colors)
function render(){
  boardEl.innerHTML = '';
  const coords = [];
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      coords.push({x:f,y:r});
    }
  }
  if(flip) coords.reverse();
  coords.forEach(pos=>{
    const {x,y} = pos;
    const rx = flip ? 7-x : x;
    const ry = flip ? 7-y : y;

    const sq = document.createElement('div');
    sq.className = 'square ' + (((x+y)%2===0) ? 'light' : 'dark');
    sq.dataset.x = rx; sq.dataset.y = ry;

    // last move highlight
    const last = movesList[movesList.length-1];
    if(last){
      if((last.from.x===rx && last.from.y===ry) || (last.to.x===rx && last.to.y===ry)){
        sq.classList.add('lastMove');
      }
    }

    // selected highlight
    if(selected && selected.x===rx && selected.y===ry) sq.classList.add('highlight');

    // legal move markers
    if(legalMoves.some(m=>m.x===rx && m.y===ry)){
      const marker = document.createElement('div');
      if(getPiece(rx,ry)){
        marker.style.boxShadow = 'inset 0 0 0 6px rgba(34,197,94,0.22)';
        marker.style.borderRadius = '8px';
        marker.style.pointerEvents = 'none';
        marker.style.position = 'absolute';
        marker.style.width = '80%'; marker.style.height = '80%'; marker.style.left = '10%'; marker.style.top = '10%';
        sq.appendChild(marker);
      } else {
        const dot = document.createElement('div');
        dot.className = 'marker-dot';
        dot.style.pointerEvents = 'none';
        sq.appendChild(dot);
      }
    }

    // piece (with circle behind + char on top)
    const p = getPiece(rx,ry);
    if(p){
      const el = document.createElement('div');
      el.className = 'piece ' + (p.c === 'w' ? 'white' : 'black');

      const circle = document.createElement('div');
      circle.className = 'circle';
      // slightly scale circles on dark squares for visibility
      circle.style.transform = ((x+y)%2===0) ? 'scale(0.95)' : 'scale(0.95)';

      const ch = document.createElement('div');
      ch.className = 'char';
      ch.textContent = UNICODE[p.c][p.t];

      el.appendChild(circle);
      el.appendChild(ch);
      sq.appendChild(el);
    }

    // coord label subtle
    const coord = document.createElement('div');
    coord.style.position='absolute'; coord.style.bottom='6px'; coord.style.left='6px';
    coord.style.fontSize='10px'; coord.style.opacity='0.12'; coord.style.color='#000';
    const fileNames = ['a','b','c','d','e','f','g','h'];
    coord.textContent = fileNames[rx] + (8 - ry);
    sq.appendChild(coord);

    // click handler
    sq.addEventListener('click', ()=> {
      if(gameOver) return;
      if(turn === 'w') handleClick(rx,ry);
    });

    boardEl.appendChild(sq);
  });

  renderHistory();
  updateUI();
  updateTurnBadge();
}

// show moves list in history panel
function renderHistory(){
  historyEl.innerHTML = '';
  movesList.forEach((m,i)=>{
    const node = document.createElement('div');
    node.className = 'move';
    node.innerHTML = `<div><strong>${i+1}.</strong> ${m.notation}</div><div style="opacity:.7">${m.player.toUpperCase()}</div>`;
    historyEl.appendChild(node);
  });
  historyEl.scrollTop = historyEl.scrollHeight;
}

// handle click logic (wraps selection & moving)
function handleClick(x,y){
  const clicked = getPiece(x,y);
  if(selected){
    const selP = getPiece(selected.x, selected.y);
    if(clicked && clicked.c === selP.c){
      selected = {x,y};
      legalMoves = generateMoves(x,y);
      render();
      return;
    }
    const valid = legalMoves.find(m=>m.x===x && m.y===y);
    if(valid){
      makeMove(selected.x, selected.y, x, y, 'w');
      selected = null; legalMoves = [];
      render();
      if(!gameOver) setTimeout(()=>{ if(!gameOver) botMove(); }, 350);
      return;
    } else {
      selected = null; legalMoves = [];
      render();
      return;
    }
  } else {
    if(clicked && clicked.c === turn){
      selected = {x,y};
      legalMoves = generateMoves(x,y);
      render();
      return;
    }
  }
}

// event listeners
undoBtn.addEventListener('click', ()=>{ undo(); });
resetBtn.addEventListener('click', ()=>{ if(confirm('Reset board?')) resetBoard(); });
flipBtn.addEventListener('click', ()=>{ flip = !flip; render(); });
exportBtn.addEventListener('click', ()=> {
  if(movesList.length===0){ alert('No moves yet'); return; }
  const txt = movesList.map((m,i)=>`${i+1}. ${m.notation}`).join('\n');
  const w = window.open('', '_blank');
  w.document.write('<pre style="font-family:monospace;padding:20px;">'+txt+'</pre>');
  w.document.title = 'Export moves';
});

// initialization
resetBoard();

// expose for debugging if needed
window._miniChess = { board, makeMove: makeMove, generateMoves: generateMoves };

</script>
</body>
</html>
