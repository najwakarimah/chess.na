<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess — Game Catur Keren</title>
<link rel="preconnect" href="https://fonts.gstatic.com">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#16a34a; /* hijau aksen */
    --light:#f8fafc;
    --square-light:#f3efe8;
    --square-dark:#c8d6c2;
    --glass: rgba(255,255,255,0.04);
    --glass-2: rgba(255,255,255,0.02);
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071023 0%, #071723 60%);font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px;}

  .app{
    width:100%;
    max-width:1100px;
    display:grid;
    grid-template-columns: 560px 1fr;
    gap:28px;
    align-items:start;
  }

  /* Board Panel */
  .board-panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:16px;
    padding:18px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.03);
  }

  .top-row{
    display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;
  }
  .title{
    color:var(--light);font-weight:700;font-size:18px;
    display:flex;gap:10px;align-items:center;
  }
  .badge{
    background:linear-gradient(90deg,#1f9a57,#0ea5a1);
    padding:6px 10px;border-radius:999px;color:white;font-weight:600;font-size:13px;
    box-shadow:0 6px 18px rgba(14,165,175,0.12);
  }

  .controls{display:flex;gap:8px;align-items:center;}
  .btn{
    background:var(--glass);
    color:var(--light);
    padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
    cursor:pointer;font-weight:600;font-size:13px;
    transition:transform .14s ease, background .14s;
  }
  .btn:hover{transform:translateY(-3px)}
  .btn.primary{background:linear-gradient(90deg,#10b981,#34d399);color:#042014;border:none}

  .board{
    width:524px; height:524px; display:grid; grid-template-columns:repeat(8,1fr); border-radius:12px; overflow:hidden; position:relative;
    user-select:none; touch-action:manipulation;
  }

  .square{
    width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative;
    font-size:34px; transition:background .12s ease, transform .12s ease;
  }
  .square.light{background:var(--square-light)}
  .square.dark{background:var(--square-dark)}
  .square:hover{transform:translateY(-3px)}
  .piece{pointer-events:none; transition:transform .12s ease;}
  .highlight{box-shadow: inset 0 0 0 4px rgba(16,185,129,0.22); border-radius:6px; animation: pulse 1.2s infinite; }
  @keyframes pulse {0%{box-shadow: inset 0 0 0 4px rgba(16,185,129,0.18);}50%{box-shadow: inset 0 0 0 6px rgba(16,185,129,0.10);}100%{box-shadow: inset 0 0 0 4px rgba(16,185,129,0.18);} }

  .lastMove{outline:3px solid rgba(59,130,246,0.22);border-radius:6px}

  /* Right panel */
  .info-panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:16px;padding:18px;border:1px solid rgba(255,255,255,0.03);
    height:524px; display:flex; flex-direction:column; gap:12px;
  }

  .players{
    display:flex;gap:12px;align-items:center;justify-content:space-between;
  }
  .player{
    display:flex;gap:12px;align-items:center;
  }
  .avatar{
    width:52px;height:52px;border-radius:12px;background:linear-gradient(180deg,#d1fae5,#bbf7d0);display:flex;align-items:center;justify-content:center;font-weight:700;color:#065f46;
    box-shadow:0 6px 18px rgba(16,185,129,0.08);
  }
  .pname{color:var(--light);font-weight:600}
  .turn{font-size:13px;color:#9ca3af;font-weight:600}

  .history{flex:1;overflow:auto;padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);color:#d1d5db;font-size:14px}
  .move{padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));display:flex;justify-content:space-between;align-items:center}
  .move strong{color:var(--light)}

  .status{padding:10px;border-radius:10px;background:var(--glass-2);color:#cbd5e1;font-weight:600;text-align:center}

  .footer-info{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .small{font-size:12px;color:#9ca3af}

  /* responsive */
  @media(max-width:980px){
    .app{grid-template-columns:1fr;max-width:720px}
    .board{width:min(92vw,560px);height:min(92vw,560px)}
    .info-panel{height:auto}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="app">

    <!-- Board Panel -->
    <div class="board-panel">
      <div class="top-row">
        <div class="title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="filter:drop-shadow(0 4px 10px rgba(0,0,0,0.3))"><path d="M5 20h14" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 3v5" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="2" fill="white"/></svg> Chess — NANA Edition</div>
        <div class="controls">
          <div class="badge" id="turnBadge">White to move</div>
          <button class="btn" id="undoBtn" title="Undo last move">Undo</button>
          <button class="btn primary" id="resetBtn" title="Reset board">Reset</button>
        </div>
      </div>

      <div id="board" class="board" aria-label="Chess board"></div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
      <div class="players">
        <div class="player">
          <div class="avatar">W</div>
          <div>
            <div class="pname">White</div>
            <div class="turn" id="whiteClock">—</div>
          </div>
        </div>
        <div class="player" style="justify-content:flex-end">
          <div style="text-align:right">
            <div class="pname">Black</div>
            <div class="turn" id="blackClock">—</div>
          </div>
          <div class="avatar" style="background:linear-gradient(180deg,#dbeafe,#bfdbfe);color:#08306b">B</div>
        </div>
      </div>

      <div class="status" id="status">Ready — klik sebuah bidak untuk mulai</div>

      <div class="history" id="history" aria-live="polite"></div>

      <div class="footer-info">
        <div class="small">Moves: <span id="moveCount">0</span></div>
        <div style="display:flex;gap:8px">
          <button class="btn" id="flipBtn">Flip Board</button>
          <button class="btn" id="exportBtn" title="Export moves (simple)">Export</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/*
  Simple Chess Game (client-only)
  - Board model: 8x8 array, each cell null or {type, color}
  - Types: p(awn), n(ight), b(ishop), r(ook), q(ueen), k(ing)
  - Colors: 'w' or 'b'
  - Click-to-select + highlight legal-looking moves (basic rules)
  - Pawn promotion supported (promote to Queen by default with prompt option)
  - Move history + undo + reset + flip board + export moves
  - NOTE: This implementation covers standard piece moves and pawn double-step/captures.
    Castling and en-passant and full checkmate validation are not implemented in this version.
*/

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const historyEl = document.getElementById('history');
const moveCountEl = document.getElementById('moveCount');
const turnBadge = document.getElementById('turnBadge');

let board = []; // 8x8
let selected = null; // {x,y}
let legalMoves = []; // [{x,y}]
let history = []; // store board snapshots for undo
let movesList = []; // simple moves
let turn = 'w'; // 'w' or 'b'
let flip = false;

// Unicode pieces (nice crisp)
const UNICODE = {
  'w': { p:'♙', r:'♖', n:'♘', b:'♗', q:'♕', k:'♔' },
  'b': { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚' }
};

// initialize starting position
function resetBoard(){
  board = [
    [ {t:'r',c:'b'},{t:'n',c:'b'},{t:'b',c:'b'},{t:'q',c:'b'},{t:'k',c:'b'},{t:'b',c:'b'},{t:'n',c:'b'},{t:'r',c:'b'} ],
    [ {t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'},{t:'p',c:'b'} ],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [ {t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'},{t:'p',c:'w'} ],
    [ {t:'r',c:'w'},{t:'n',c:'w'},{t:'b',c:'w'},{t:'q',c:'w'},{t:'k',c:'w'},{t:'b',c:'w'},{t:'n',c:'w'},{t:'r',c:'w'} ]
  ];
  selected = null; legalMoves = []; history = []; movesList = []; turn='w';
  saveSnapshot();
  render();
  setStatus('Ready — pilih bidak putih untuk mulai');
}

// Save snapshot for undo
function saveSnapshot(){
  history.push(JSON.stringify(board));
  if(history.length>200) history.shift();
}

// Undo last move
function undo(){
  if(history.length>1){
    history.pop();
    board = JSON.parse(history[history.length-1]);
    movesList.pop();
    turn = (turn === 'w') ? 'b' : 'w';
    updateUI();
    render();
  } else {
    alert('Tidak ada langkah untuk di-undo.');
  }
}

// Utilities
function inside(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
function getPiece(x,y){ return inside(x,y) ? board[y][x] : null; }
function setPiece(x,y,p){ if(inside(x,y)) board[y][x] = p; }

function render(){
  boardEl.innerHTML='';
  // create 64 squares
  const coords = [];
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      coords.push({x:f,y:r});
    }
  }
  if(flip) coords.reverse();
  coords.forEach((pos, idx) => {
    const {x,y} = pos;
    const rx = flip ? 7-x : x;
    const ry = flip ? 7-y : y;
    const square = document.createElement('div');
    const light = ((x+y)%2===0);
    square.className = 'square ' + (light ? 'light' : 'dark');
    square.dataset.x = rx;
    square.dataset.y = ry;

    // last move highlight
    const last = movesList[movesList.length-1];
    if(last){
      if((last.from.x===rx && last.from.y===ry) || (last.to.x===rx && last.to.y===ry)){
        square.classList.add('lastMove');
      }
    }

    // if selected piece is here -> add outline
    if(selected && selected.x===rx && selected.y===ry){
      square.classList.add('highlight');
    }

    // if legal move -> show marker
    if(legalMoves.some(m=>m.x===rx && m.y===ry)){
      const marker = document.createElement('div');
      marker.style.position='absolute';
      marker.style.width='54px';
      marker.style.height='54px';
      marker.style.borderRadius='50%';
      marker.style.opacity='0.85';
      marker.style.display='flex';
      marker.style.alignItems='center';
      marker.style.justifyContent='center';
      // if occupied -> ring, else dot
      if(getPiece(rx,ry)){
        marker.style.boxShadow='inset 0 0 0 6px rgba(16,185,129,0.22)';
      } else {
        marker.style.width='16px'; marker.style.height='16px';
        marker.style.background='rgba(16,185,129,0.85)';
      }
      marker.style.pointerEvents='none';
      square.appendChild(marker);
    }

    // piece
    const p = getPiece(rx,ry);
    if(p){
      const piece = document.createElement('div');
      piece.className = 'piece';
      piece.textContent = UNICODE[p.c][p.t];
      piece.style.fontSize='36px';
      piece.style.cursor = (p.c === turn) ? 'pointer' : 'default';
      square.appendChild(piece);
    }
    // coordinates label (optional subtle)
    const coordLabel = document.createElement('div');
    coordLabel.style.position='absolute';
    coordLabel.style.bottom='6px';
    coordLabel.style.left='6px';
    coordLabel.style.fontSize='10px';
    coordLabel.style.color='rgba(0,0,0,0.45)';
    // show a1-h8 depending on orientation
    const fileNames = ['a','b','c','d','e','f','g','h'];
    const rank = 8 - ry;
    const file = fileNames[rx];
    coordLabel.textContent = file + rank;
    coordLabel.style.opacity='0.12';
    square.appendChild(coordLabel);

    // click handler
    square.addEventListener('click',()=>{
      handleSquareClick(rx,ry);
    });

    boardEl.appendChild(square);
  });

  updateUI();
  renderHistory();
}

function updateUI(){
  document.getElementById('moveCount').innerText = movesList.length;
  turnBadge.innerText = (turn==='w')? 'White to move':'Black to move';
  document.getElementById('status').innerText = `Turn: ${(turn==='w')?'White':'Black'} • Click a piece to show moves`;
  document.getElementById('whiteClock').innerText = 'White';
  document.getElementById('blackClock').innerText = 'Black';
}

function renderHistory(){
  historyEl.innerHTML='';
  movesList.forEach((m,i)=>{
    const node = document.createElement('div');
    node.className = 'move';
    const left = document.createElement('div');
    left.innerHTML = `<strong>${i+1}.</strong> ${m.notation}`;
    const right = document.createElement('div');
    right.style.color='#9ca3af'; right.style.fontSize='13px';
    right.textContent = m.player.toUpperCase();
    node.appendChild(left); node.appendChild(right);
    historyEl.appendChild(node);
  });
  historyEl.scrollTop = historyEl.scrollHeight;
}

// Generate legal-ish moves for piece at (x,y)
// This function enforces movement rules and basic capture rules.
// It DOES NOT check for moving into check.
function generateMoves(x,y){
  const p = getPiece(x,y);
  if(!p) return [];
  const moves = [];
  const color = p.c;
  const dir = (color==='w') ? -1 : 1; // pawn direction: white goes up (decreasing y)
  if(p.t === 'p'){
    // one step
    const ny = y + dir;
    if(inside(x,ny) && !getPiece(x,ny)){
      moves.push({x, y:ny});
      // two-step from start
      const startRow = (color==='w') ? 6 : 1;
      const ny2 = y + 2*dir;
      if(y === startRow && !getPiece(x,ny2)){
        moves.push({x, y:ny2});
      }
    }
    // captures
    for(const dx of [-1,1]){
      const cx = x + dx, cy = y + dir;
      if(inside(cx,cy)){
        const target = getPiece(cx,cy);
        if(target && target.c !== color) moves.push({x:cx,y:cy});
      }
    }
    // TODO: en-passant not implemented
  } else if(p.t === 'n'){
    const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
    deltas.forEach(d=>{
      const nx=x+d[0], ny=y+d[1];
      if(inside(nx,ny)){
        const t = getPiece(nx,ny);
        if(!t || t.c !== color) moves.push({x:nx,y:ny});
      }
    });
  } else if(p.t === 'b' || p.t === 'r' || p.t === 'q'){
    const directions = [];
    if(p.t === 'b' || p.t === 'q'){
      directions.push([1,1],[1,-1],[-1,1],[-1,-1]);
    }
    if(p.t === 'r' || p.t === 'q'){
      directions.push([1,0],[-1,0],[0,1],[0,-1]);
    }
    directions.forEach(d=>{
      let nx = x + d[0], ny = y + d[1];
      while(inside(nx,ny)){
        const t = getPiece(nx,ny);
        if(!t) {
          moves.push({x:nx,y:ny});
        } else {
          if(t.c !== color) moves.push({x:nx,y:ny});
          break;
        }
        nx += d[0]; ny += d[1];
      }
    });
  } else if(p.t === 'k'){
    for(const dx of [-1,0,1]){
      for(const dy of [-1,0,1]){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(inside(nx,ny)){
          const t = getPiece(nx,ny);
          if(!t || t.c !== color) moves.push({x:nx,y:ny});
        }
      }
    }
    // castling not implemented
  }
  return moves;
}

// Handle click on board square
function handleSquareClick(x,y){
  const clicked = getPiece(x,y);
  if(selected){
    // if clicked on same color piece => change selection
    const selPiece = getPiece(selected.x, selected.y);
    if(clicked && clicked.c === selPiece.c){
      selected = {x,y};
      legalMoves = generateMoves(x,y);
      render();
      return;
    }

    // if clicked is in legalMoves => move
    const move = legalMoves.find(m=>m.x===x && m.y===y);
    if(move){
      makeMove(selected.x, selected.y, x, y);
      selected = null; legalMoves = [];
      render();
      return;
    } else {
      // not valid move: deselect
      selected = null; legalMoves = [];
      render();
      return;
    }

  } else {
    // no selection yet: select if piece of current turn
    if(clicked && clicked.c === turn){
      selected = {x,y};
      legalMoves = generateMoves(x,y);
      render();
      return;
    } else {
      // click empty or opponent piece -> nothing
      selected = null; legalMoves = [];
      render();
    }
  }
}

// Execute move from (fx,fy) to (tx,ty)
function makeMove(fx,fy,tx,ty){
  const p = getPiece(fx,fy);
  if(!p) return;
  const captured = getPiece(tx,ty);
  // move
  setPiece(tx,ty,p);
  setPiece(fx,fy,null);

  // promotion
  if(p.t === 'p'){
    if((p.c === 'w' && ty === 0) || (p.c === 'b' && ty === 7)){
      // prompt for promotion piece
      const choice = prompt("Promosi! Pilih: q (Ratu), r (Benteng), b (Gajah), n (Kuda). Default q", "q");
      const promote = (choice && ['q','r','b','n'].includes(choice.toLowerCase())) ? choice.toLowerCase() : 'q';
      setPiece(tx,ty,{t:promote,c:p.c});
    }
  }

  // add to movesList
  const notation = `${p.c}${p.t}:${fileRank(fx,fy)}→${fileRank(tx,ty)}${captured?(' x'+captured.t):''}`;
  movesList.push({player: p.c, notation, from:{x:fx,y:fy}, to:{x:tx,y:ty}});
  saveSnapshot();
  // toggle turn
  turn = (turn === 'w') ? 'b' : 'w';
  updateUI();
}

// fileRank helper e.g. a2
function fileRank(x,y){
  const files=['a','b','c','d','e','f','g','h'];
  return files[x] + (8 - y);
}

// Flip board
document.getElementById('flipBtn').addEventListener('click', ()=> { flip = !flip; render(); });

// Reset btn
document.getElementById('resetBtn').addEventListener('click', ()=> {
  if(confirm('Reset board ke posisi awal?')) resetBoard();
});

// Undo
document.getElementById('undoBtn').addEventListener('click', undo);

// Export moves
document.getElementById('exportBtn').addEventListener('click', ()=>{
  if(movesList.length===0){ alert('Belum ada langkah.'); return; }
  const txt = movesList.map((m,i)=>`${i+1}. ${m.notation}`).join('\n');
  // show in new window
  const w = window.open('', '_blank');
  w.document.write('<pre style="font-family:monospace;padding:20px;">'+txt+'</pre>');
  w.document.title = 'Moves export';
});

// Small keyboard shortcuts
window.addEventListener('keydown', e=>{
  if(e.key === 'z' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); undo(); }
  if(e.key === 'r' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); if(confirm('Reset?')) resetBoard(); }
});

// initial setup
resetBoard();

// expose for debugging
window._chess = {board, makeMove, generateMoves};
</script>
</body>
</html>
